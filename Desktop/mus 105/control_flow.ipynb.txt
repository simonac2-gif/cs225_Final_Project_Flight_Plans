{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Control Flow\n",
    "This tutorial explains how logical expressions can be used to manipulate data in Python programs."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Control Flow:\n",
    "Control flow is the order in which statements and expressions are evaluated. \n",
    "Through control flow the programmer can skip code or repeat code given certain conditions. Control flow is fundamental to program development. This tutorial covers the two most import types of control flow:\n",
    "\n",
    "* Conditionals: if, else, elif (else if)\n",
    "* Iteration (Looping): while, for"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Conditionals (if ... elif ... else)\n",
    "\n",
    "An 'if statement' evaluates a boolean expression, checks whether or not it is true, and executes a block of code within the statement if the expression was true.  In Python, the 'block of code' is denoted by indenting the lines following the if statement"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "my_boolean = True\n",
    "\n",
    "if my_boolean:\n",
    "    print(\"This should be printed!\")\n",
    "    print(\"This line should also be printed\")\n",
    "print(\"This line is out of the body and will be printed regardless\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "my_boolean = False\n",
    "\n",
    "if my_boolean :\n",
    "    print(\"This should NOT be printed!\")\n",
    "    print(\"This line should also NOT be printed\")\n",
    "print(\"This line is out of the body and will be printed regardless\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### else \n",
    "By adding an 'else' statement after the first if statement, we can have code that executes when the boolean expression is false"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "my_boolean = True\n",
    "if my_boolean:\n",
    "    print(\"This will only be printed if my_boolean is TRUE...\")\n",
    "else: #notice how the else statement is not in the same closure\n",
    "    print(\"This will only be printed if my_boolean is FALSE...\")\n",
    "print(\"This line is out of the body and will be printed regardless\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "my_boolean = False\n",
    "if my_boolean:\n",
    "    print(\"This will only be printed if my_boolean is TRUE...\")\n",
    "else: #notice how the else statement is not in the same closure\n",
    "    print(\"This will only be printed if my_boolean is FALSE...\")\n",
    "print(\"This line is out of the body and will be printed regardless\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### elif (else if)\n",
    "We can add more if statements after the first if statement by using elif statements. You can add as many elif's as you want!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "my_boolean, my_boolean2 = False, True\n",
    "\n",
    "if my_boolean:\n",
    "    print(\"This will only be printed if my_boolean is TRUE...\")\n",
    "elif my_boolean2:\n",
    "    print(\"This will be printed if my_boolean is FALSE and my_boolean2 is TRUE!\")\n",
    "else:\n",
    "    print(\"This will be printed if both my_boolean and my_boolean2 are FALSE!\")\n",
    "print(\"This line is out of the closure and will be printed regardless\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Notice how only the code in the elif ran, and not code in the if or else statement. **For one chain of 'if elif... else'  statements, only code from the first true clause will be run**."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Loops\n",
    "  \n",
    "### for *var* in *iterator* ...\n",
    "\n",
    "The *for* loop takes a Python *iterator* (a list, tuple, dictionary, set, generator, range, generator, etc...) and executes the code in the loop for each element the iterator yields. The loop terminates when the iterator stops yielding values."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# range returns  an iterator from 0 to n - 1\n",
    "for i in range(10):\n",
    "    print(i)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# a 'list comprehension'\n",
    "for n in [i for i in range(0, 10, 2)]:\n",
    "    print('*' * n)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# strings can also be looped through\n",
    "for c in \"hello world\":\n",
    "    print(c)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# we can iterate both elements and their indexes\n",
    "for i, c in enumerate(\"hello world\"):\n",
    "    print(i, c)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# iterate through two lists at the same time\n",
    "l1 = [1,2,3]\n",
    "l2 = [4,5,6]\n",
    "\n",
    "for a, b in zip(l1, l2):\n",
    "    print(a, b)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# iterate dictionary comprehensions...\n",
    "dict_iter = {n: '*' * n for n in range(10)}\n",
    "print(dict_iter)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# What do you think this will print??\n",
    "for k in dict_iter:\n",
    "    print(k)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for k in dict_iter:\n",
    "    print(dict_iter[k])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### while *boolean* ... \n",
    "\n",
    "The while statement performs its code in a loop, as long as a boolean expression is true. The boolean expression will be reevaluated after each iteration of the loop."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# same thing as the for loop??\n",
    "n = 0\n",
    "while n < 10:\n",
    "    print(n)\n",
    "    n += 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "n = 0\n",
    "while n != 10:\n",
    "    print(n)\n",
    "    n += 1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### The break statement\n",
    "The break statement be used inside for or while loops to exit the loop. An optional else statement can be put after a loop, which will execute if the loop was not broken out of.  avoid using this too much...atleast that's the general consensus"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i in range(10):\n",
    "    print(i)\n",
    "    if i == 5:\n",
    "        break"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "n = 0\n",
    "while True: # how can we ever exit a while true loop??\n",
    "    print(n)\n",
    "    if n == 5:\n",
    "        break\n",
    "    n += 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# an else statement on a loop is executed if the loop IS NOT broken out of\n",
    "\n",
    "names = ['John', 'Jeff', 'Jenny', 'James', 'Janice']\n",
    "my_name = 'Jerry'\n",
    "\n",
    "for name in names:\n",
    "    if name == my_name:\n",
    "        print(\"Found my name!\")\n",
    "        break\n",
    "else:\n",
    "    print(\"You're name wasn't found, but we've added it now!\")\n",
    "    names.append(my_name)\n",
    "print(names)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for name in names:\n",
    "    if name == my_name:\n",
    "        print(\"Found my name!\")\n",
    "        break\n",
    "else:\n",
    "    print(\"You're name wasn't found, but we've added it now!\")\n",
    "    names.append(my_name)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### The continue Statement\n",
    "* Similar to a break statement, in that it alters the loop flow but instead of exiting the entire loop, it just continues to the next iteration immediately so that any code after the continue is **NOT** executed on the current pass."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i in range(10):\n",
    "    if i == 5:\n",
    "        continue\n",
    "    print(i)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "n = 0\n",
    "while n < 10:\n",
    "    print(n)\n",
    "    if n == 5:\n",
    "        continue\n",
    "    n += 1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Beware the infinite loop!\n",
    "\n",
    "When coding you will probably run into the occasional infinite loop, where the loop logic makes it impossible to terminate the loop. Suspect infinite loops when your code is taking an unreasonable amount of time to run... You can confirm infinite loops by adding print statements or adding break points in the debugger.  Know how to terminate code in your environment: use the stop button in Pycharm, control-c in the Terminal or VS Code, and Kernel -> Interrupt in Jupyter notebooks."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
